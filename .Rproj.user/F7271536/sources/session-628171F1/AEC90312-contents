---
title: "Evaluación de Cramer von Mises"
author: "Denis Berroeta"
date: "12-07-2022"
output:
  pdf_document:
    toc: yes
    toc_depth: '3'
    includes:
      in_header: header.tex
  html_document:
    toc: yes
    toc_depth: '3'
    df_print: paged
link-citations: yes
bibliography: references.bib
subtitle: Evaluación de Modelos para ciudad de la Serena-Chile
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
require(knitr)
library(ggplot2)
```

```{r echo=FALSE, warning=FALSE,message=FALSE}
source("scripts/recursos.R")
source("scripts/funciones.R")

print.syrjala.test <-
  function (x, ...)
  {
    cat(
      "Cramer-von Misses test for the difference between\nthe spatial distributions of ",
      x$datanames[1],
      "and",
      x$datanames[2],
      "\nbased on",
      x$nperm,
      "permutations.\n\n"
    )
    cat("   psi:    ", x$cvm.obs, "\n")
    cat("   p-value:", sum(x$cvm.sim >= x$cvm.obs) / (x$nperm +
                                                        1), "\n\n")
    cat(
      "Kolmogorov-Smirnov test for the difference between\nthe spatial distributions of ",
      x$datanames[1],
      "and",
      x$datanames[2],
      "\nbased on",
      x$nperm,
      "permutations.\n\n"
    )
    cat("   psi:    ", x$ks.obs, "\n")
    cat("   p-value:", sum(x$ks.sim >= x$ks.obs) / (x$nperm +
                                                      1), "\n\n")
  }
```

## Introducción:

En el estudio de las distribuciones espaciales o geográficas de las poblaciones, surgen preguntas sobre si la distribución de una población difiere de la de otra. Por ejemplo, dentro de una especie, ¿se distribuyen de forma diferente los machos y las hembras o los jóvenes y los adultos? [@syrjala1996], para la el caso de nuestro estudio establecer la diferencia entre la distribución espacial de los resultados de predicción del del modelo modelo multinivel de un intercepto ("Intercept only multilevel models", *glmer.nb* package of R Project) versus los valores reales de los delitos.

## Marco Metodológico:

### Función `syrjala` {ecespa}

Calcula una prueba de dos muestras del tipo Cramer-von Mises (y Kolmogorov-Smirnov) para una diferencia entre las distribuciones espaciales de dos poblaciones. Está diseñada para ser sensible a las diferencias en la forma en que se distribuyen las poblaciones en el área de estudio, pero insensible a las diferencias de abundancia entre las dos poblaciones.

La hipótesis nula de la prueba de Syrjala es que, en toda el área de estudio, las distribuciones normalizadas de las dos poblaciones son las mismas (Syrjala, 1996). Los datos de densidad de población se recogen en K lugares de muestreo de dos poblaciones. Dejemos que (xk, yk) denote las coordenadas de la kª ubicación de muestreo ( k= 1,...,K ); dejemos que d.i(xk, yk) denote la densidad de la muestra en la Kª ubicación de muestreo de la iª población. Para construir una prueba que sea independiente de los tamaños de la población, primero se normalizan los datos de densidad observados:

$$gamma.i(xk, yk) = \frac{di(xk, yk)}{Di}$$

$Di$: Es la suma de las observaciones $d.i(xk, yk)$ en los K lugares de muestreo. El valor de la función de distribución acumulativa en la ubicación $(xk, yk)$ para la i-ésima población, denominada $GAMMA.i(xk, yk)$, es la suma de todas las observaciones de densidad normalizada, $gamma.i(xk, yk)$, cuya ubicación $(x, y)$ es tal que $x <= xk$ e $y <= yk$.

El estadístico propuesto por Syrjala para probar la hipótesis nula es el cuadrado de la diferencia entre las funciones de distribución acumulativa de las dos poblaciones, sumadas sobre todas las ubicaciones de muestreo, es decir:

$$psi = \sum{(GAMMA.1(xk, yk) - GAMMA.2(xk, yk)})^2$$

Como *psi* no es invariable con respecto a la "esquina" del rectángulo que encierra el área de estudio y que se elige como origen del sistema de coordenadas, psi se calcula cuatro veces, una con cada esquina como origen, y el promedio de psi se emplea como estadística de prueba.

El nivel de significación del *psi* observado se determina a partir de su posición en el conjunto ordenado de valores estadísticos de prueba de todas las $2^K$ permutaciones por pares (que se aproxima a partir de un gran número de permutaciones seleccionadas al azar).

## Experimentación

Para efectos explicativos de este documento se realizará el flujo de evaluación de dos distribuciones espaciales usando de la Ciduad de la Serena-Coquimbo y para los delitos de Hurto

### Lectura de Insumos

**Recursos y funciones**

```{r eval=FALSE}
source("scripts/recursos.R")
source("scripts/funciones.R")

```

**Definición de Variables Generales**
```{r}
stats=data.frame(matrix(c("1","2","viol","crim","abus","amen","asalto",
                          "robo","hurto","pobdens","tamhog","flux",
                          "ofcom","educ","vuln","mobil"),16,1))
names(stats)="Variables"
```


**Selección de la Ciudad y delito**

```{r}
# ciudades=gsub(".rds","",list.files("data",pattern="urb"))
# cities=ciudades
ciudad="urb_4_18"
city <- ciudad
# delitos=c("hurto","robo","asalto","amen","abus","crim","viol")
delito="hurto"
```


**Lectura de Información de la Ciudad**

```{r}
cityp = readRDS(paste0("data/", ciudad, ".rds"))
citystat=readRDS(paste0("data/",gsub("urb","stat",ciudad),".rds"))
cityst=c(ciudad,citystat$n[8],as.integer(citystat$n[11]),as.integer(citystat$n[10]))
citystat=rbind(rep(city,3),c("N","Mean","StD"),citystat)
stats=cbind(stats,citystat)
```

**Visualización de Datos Ciudad**
```{r}
city_sf <- st_as_sf(cityp, crs = st_crs(4326))
mapview::mapview(cityp, zcol= "hurto", cex = 2)
```

Creación de variable `coords`

```{r}
coords <- spTransform(cityp, CRS("+init=epsg:32719")) 
coords <- coords@coords %>% as.data.frame()
```


### Lectura de Modelos SAR

# ```{r}
# lagcent=readRDS(paste0("output/",ciudad,"_lgct_",delito,".rds"))
# lagflux=readRDS(paste0("output/",ciudad,"_lgfl_",delito,".rds"))
# cpcent=readRDS(paste0("output/",ciudad,"_ctcn_",delito,".rds"))
# cpflux=readRDS(paste0("output/",ciudad,"_flcn_",delito,".rds"))
# centflux=readRDS(paste0("output/",ciudad,"_ctfl_",delito,".rds"))
# ```

```{r}
sar_lagcent=readRDS(paste0("output/",city,"_lagsarct_",delito,".rds"))
sar_lagflux=readRDS(paste0("output/",ciudad,"_lagsarfl_",delito,".rds"))
sar_cpcent=readRDS(paste0("output/",ciudad,"_lagsar_ctcn_",delito,".rds"))
sar_cpflux=readRDS(paste0("output/",ciudad,"lagsar_flcn_",delito,".rds"))
sar_centflux=readRDS(paste0("output/",ciudad,"lagsar_ctfl_",delito,".rds"))
```


### Evaluación de Cramer von Mises 

Corresponde a la evaluación de los modelos para el delito de Hurto en ciudad de estudio, donde se compara los datos predichos por el modelo respecto a los datos reales.

```{r}
# Función de evaluación de crames von mises
cvm_eval <- function(model, coords, nperm = 999){
  predic_model <- predict(model, model@frame[, -1]) %>% 
    abs()%>% 
    as.vector()
  model_cvm <- syrjala0(coords = coords,R = F,
                       var1 = model@frame[, 1],
                       var2 = predic_model, nsim = nperm)
  return(model_cvm)
}
```



```{r eval=FALSE}
lagcent_cvm <-  cvm_eval(model = sar_lagcent, coords = coords)
lagflux_cvm <-  cvm_eval(model = sar_lagflux, coords = coords)
cpcent_cvm <-  cvm_eval(model = sar_cpcent, coords = coords)
cpflux_cvm <-  cvm_eval(model = sar_cpflux, coords = coords)
centflux_cvm <-  cvm_eval(model = sar_centflux, coords = coords)
```

### Consolidación de Resultados

```{r eval=FALSE}
resultados <- list(lagcent_cvm, lagflux_cvm, cpcent_cvm, cpflux_cvm,
                   centflux_cvm)
nombres_res <-
  c("lagcent_cvm",
    "lagflux_cvm",
    "cpcent_cvm",
    "cpflux_cvm",
    "centflux_cvm")

names(resultados) <- nombres_res

# saveRDS(resultados, "data/cvm_urb_4_18_hurto.rds")
```


## Revisión de Resultados:

```{r echo=FALSE}
resultados <-  readRDS("data/cvm_urb_4_18_hurto.rds")
```


```{r echo=FALSE}

psi_cvm <- c()
psi_ks <- c()
for(i in 1:length(resultados)){
  psi_cvm <-  c(psi_cvm, resultados[[i]][[1]])
  psi_ks <-  c(psi_ks, resultados[[i]][[3]])
}

tabla_res <- data.frame(modelos = names(resultados), psi_cvm, psi_ks)

kable(tabla_res, digits = 3, row.names = FALSE, align = "c",
              caption = NULL)

```


## Resultados por modelo

### Modelo  `lagcent`

```{r echo=FALSE}
print.syrjala.test(resultados[[1]])
```


### Visualización de las Diferencias de Distribuciones Acumuladas

```{r}

model <-  lagcent
predic_model <- predict(model, model@frame[, -1]) %>% 
    abs()%>% 
    as.vector()

empiric_values <- model@frame[, 1]


minMax <- seq(min(c(predic_model, empiric_values)), 
                  max(c(predic_model, empiric_values)),
                      length.out = length(empiric_values))

cdf_df <- data.frame(x = minMax, 
                     min = ecdf(predic_model)(minMax), 
                     max = ecdf(empiric_values)(minMax))


df_predic <-  data.frame(values = predic_model, group = "predict")
df_empiric <-  data.frame(values = empiric_values, group = "empiric")
datos <-  rbind(df_predic, df_empiric)


ggplot(datos, aes(x = values)) +
  stat_ecdf(aes(colour = group, linetype = group), size = 1) +
  geom_segment(aes(x = x, xend = x, y = min, yend = max), 
               data = cdf_df, color = "red") +
  xlim(0, 25)+
  labs(x = "x", y = "Cumulitive Distibution", 
       main = "K-S Test: Sample 1 / Sample 2")
```



### Modelo  `lagflux`

```{r echo=FALSE}
print.syrjala.test(resultados[[2]])
```


### Visualización de las Diferencias de Distribuciones Acumuladas

```{r}

model <-  lagflux
predic_model <- predict(model, model@frame[, -1]) %>% 
    abs()%>% 
    as.vector()

empiric_values <- model@frame[, 1]


minMax <- seq(min(c(predic_model, empiric_values)), 
                  max(c(predic_model, empiric_values)),
                      length.out = length(empiric_values))

cdf_df <- data.frame(x = minMax, 
                     min = ecdf(predic_model)(minMax), 
                     max = ecdf(empiric_values)(minMax))


df_predic <-  data.frame(values = predic_model, group = "predict")
df_empiric <-  data.frame(values = empiric_values, group = "empiric")
datos <-  rbind(df_predic, df_empiric)


ggplot(datos, aes(x = values)) +
  stat_ecdf(aes(colour = group, linetype = group), size = 1) +
  geom_segment(aes(x = x, xend = x, y = min, yend = max), 
               data = cdf_df, color = "red") +
  xlim(0, 25)+
  labs(x = "x", y = "Cumulitive Distibution", 
       main = "K-S Test: predict / empiric")
```




### Modelo  `cpcent`

```{r echo=FALSE}
print.syrjala.test(resultados[[3]])
```


### Visualización de las Diferencias de Distribuciones Acumuladas

```{r}

model <-  cpcent
predic_model <- predict(model, model@frame[, -1]) %>% 
    abs()%>% 
    as.vector()

empiric_values <- model@frame[, 1]


minMax <- seq(min(c(predic_model, empiric_values)), 
                  max(c(predic_model, empiric_values)),
                      length.out = length(empiric_values))

cdf_df <- data.frame(x = minMax, 
                     min = ecdf(predic_model)(minMax), 
                     max = ecdf(empiric_values)(minMax))


df_predic <-  data.frame(values = predic_model, group = "predict")
df_empiric <-  data.frame(values = empiric_values, group = "empiric")
datos <-  rbind(df_predic, df_empiric)


ggplot(datos, aes(x = values)) +
  stat_ecdf(aes(colour = group, linetype = group), size = 1) +
  geom_segment(aes(x = x, xend = x, y = min, yend = max), 
               data = cdf_df, color = "red") +
  xlim(0, 25)+
  labs(x = "x", y = "Cumulitive Distibution", 
       main = "K-S Test: predict / empiric")
```




### Modelo  `lagflux`

```{r echo=FALSE}
print.syrjala.test(resultados[[4]])
```


### Visualización de las Diferencias de Distribuciones Acumuladas

```{r}

model <-  cpflux
predic_model <- predict(model, model@frame[, -1]) %>% 
    abs()%>% 
    as.vector()

empiric_values <- model@frame[, 1]


minMax <- seq(min(c(predic_model, empiric_values)), 
                  max(c(predic_model, empiric_values)),
                      length.out = length(empiric_values))

cdf_df <- data.frame(x = minMax, 
                     min = ecdf(predic_model)(minMax), 
                     max = ecdf(empiric_values)(minMax))


df_predic <-  data.frame(values = predic_model, group = "predict")
df_empiric <-  data.frame(values = empiric_values, group = "empiric")
datos <-  rbind(df_predic, df_empiric)


ggplot(datos, aes(x = values)) +
  stat_ecdf(aes(colour = group, linetype = group), size = 1) +
  geom_segment(aes(x = x, xend = x, y = min, yend = max), 
               data = cdf_df, color = "red") +
  xlim(0, 25)+
  labs(x = "x", y = "Cumulitive Distibution", 
       main = "K-S Test: predict / empiric")
```




### Modelo  `centflux`

```{r echo=FALSE}
print.syrjala.test(resultados[[5]])
```


### Visualización de las Diferencias de Distribuciones Acumuladas

```{r}

model <-  centflux
predic_model <- predict(model, model@frame[, -1]) %>% 
    abs()%>% 
    as.vector()

empiric_values <- model@frame[, 1]


minMax <- seq(min(c(predic_model, empiric_values)), 
                  max(c(predic_model, empiric_values)),
                      length.out = length(empiric_values))

cdf_df <- data.frame(x = minMax, 
                     min = ecdf(predic_model)(minMax), 
                     max = ecdf(empiric_values)(minMax))


df_predic <-  data.frame(values = predic_model, group = "predict")
df_empiric <-  data.frame(values = empiric_values, group = "empiric")
datos <-  rbind(df_predic, df_empiric)


ggplot(datos, aes(x = values)) +
  stat_ecdf(aes(colour = group, linetype = group), size = 1) +
  geom_segment(aes(x = x, xend = x, y = min, yend = max), 
               data = cdf_df, color = "red") +
  xlim(0, 25)+
  labs(x = "x", y = "Cumulitive Distibution", 
       main = "K-S Test: predict / empiric")
```


